{"meta":{"title":"hanxw-blogs","subtitle":null,"description":null,"author":"hanxw","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"ArrayList源码","slug":"ArrayList源码","date":"2019-08-07T14:05:35.000Z","updated":"2019-08-07T14:11:37.920Z","comments":true,"path":"2019/08/07/ArrayList源码/","link":"","permalink":"http://yoursite.com/2019/08/07/ArrayList源码/","excerpt":"","text":"ArrayList1、 数组介绍 在Java中，当创建数组时会在内存中划分出一块连续的内存，然后当有数据进入的时候会将数据按顺序存储在这块连续的内存中，当需要读取数组中的数据时，需要提供数组中的索引，然后数组根据索引将内存中的数据取出来，返回给读取程序，在Java中并不是所有的数据都存储到数组中，只有相同类型的数据才可以一起存到数组中。​ 因为数组在存储时是按顺序的，存储数据的内存也是连续的，所以它的特点就是寻址读取数据比较容易，插入和删除比较困难。 2、 源码分析 构造方法 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); &#125;&#125; 123456789public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 插入数据方法 12345public boolean add(E e) &#123; modCount++; add(e, elementData, size); return true;&#125; 123456private void add(E e, Object[] elementData, int s) &#123; if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1;&#125; 1234567891011 public void add(int index, E element) &#123; rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; if ((s = size) == (elementData = this.elementData).length) elementData = grow(); System.arraycopy(elementData, index,elementData, index + 1, s - index); elementData[index] = element; size = s + 1;&#125; 1234private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 扩容 123private Object[] grow() &#123; return grow(size + 1);&#125; 123private Object[] grow(int minCapacity) &#123; return elementData = Arrays.copyOf(elementData,newCapacity(minCapacity));&#125; 12345678910111213private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity);&#125; 1234567private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 删除方法 123456789public E remove(int index) &#123; Objects.checkIndex(index, size); final Object[] es = elementData; @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index]; fastRemove(es, index); return oldValue;&#125; 1234567private void fastRemove(Object[] es, int i) &#123; modCount++; final int newSize; if ((newSize = size - 1) &gt; i) System.arraycopy(es, i + 1, es, i, newSize - i); es[size = newSize] = null;&#125; 12345678910111213141516171819public boolean remove(Object o) &#123; final Object[] es = elementData; final int size = this.size; int i = 0; found: &#123; if (o == null) &#123; for (; i &lt; size; i++) if (es[i] == null) break found; &#125; else &#123; for (; i &lt; size; i++) if (o.equals(es[i])) break found; &#125; return false; &#125; fastRemove(es, i); return true;&#125;","categories":[],"tags":[]},{"title":"LinkedList源码","slug":"LinkedList源码-1","date":"2019-08-07T13:47:18.000Z","updated":"2019-08-07T13:58:01.543Z","comments":true,"path":"2019/08/07/LinkedList源码-1/","link":"","permalink":"http://yoursite.com/2019/08/07/LinkedList源码-1/","excerpt":"","text":"LinkedList1、链表介绍 ​ 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表有一系列节点（链表中每一个元素称为节点）组成，节点可以在运行时动态生成。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个节点的指针域。 双链表是链表的一种，由节点组成，每个数据节点中都有两个指针，分别指向直接后继和直接前驱。 构造方法 12public LinkedList() &#123;&#125; 1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125; 1234567891011121314151617181920212223242526272829303132333435363738public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; 插入方法 1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 123456789101112131415void linkLast(E e) &#123; final Node&lt;E&gt; l = last; //new Node=l（前继节点）, e（新创建节点）, null（后继节点） final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //设置新节点是尾结点 last = newNode; //判断链表是否有元素节点 if (l == null) first = newNode; else //设置原尾结点的后继节点是newNode l.next = newNode; size++; modCount++;&#125; 12345678910public void add(int index, E element) &#123; //判断index是否越界 checkPositionIndex(index); //index是不是尾部位置 if (index == size) linkLast(element);//此时相当于在链表最后插入节点 else //element是要插入的节点，node（index）原index位置节点 linkBefore(element, node(index));&#125; 1234private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 123private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125; 123456789101112131415//Returns the (non-null) Node at the specified element index.Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index);确保是合法的索引，即0&lt;=index&lt;=size if (index &lt; (size &gt;&gt; 1)) &#123; //index小于size的一半时，从头向后找 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123;//index大于size一半时，从尾向前找 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; 12345678910111213void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; //原index的前继节点pred final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 删除方法 1234public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125; 123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 12345678910111213141516171819202122232425E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125;","categories":[],"tags":[]},{"title":"ClassLoader","slug":"ClassLoader","date":"2019-07-29T13:43:47.000Z","updated":"2019-07-29T14:10:12.555Z","comments":true,"path":"2019/07/29/ClassLoader/","link":"","permalink":"http://yoursite.com/2019/07/29/ClassLoader/","excerpt":"","text":"ClassLoader类加载器Java虚拟机与程序的生命周期，在如下几种情况下，Java虚拟机将结束生命周期： * 执行了System.exit()方法。 * 程序正常执行结束。 * 程序在执行过程中遇到了异常或错误导致异常终止。 * 由于操作系统出现错误而导致Java虚拟机进程终止。 类的加载、连接、初始化加载：查找并加载类的二进制数据，也就是将.class字节码的信息加载到内存中。连接：又分为验证、准备、解析 * 验证：确保被加载类额正确性。 * 准备：为类的静态变量分配内存，并将其初始化为默认值。 * 解析：把类中的符号引用转化为直接引用。初始化：为类的静态变量赋予正确的初始值。 类的加载类的加载指的是将.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。加载.class文件的方式有以下几种： * 从本地系统中直接加载 * 通过网络下载.class文件 * 从zip,jar等归档文件中加载.class文件 * 从专有数据库中提取.class文件 * 将Java源文件动态编译为.class文件 初始化类Java程序对类的使用方式可分为两种：主动使用和被动使用。所有的Java虚拟机实现必须在每个类或接口被“首次主动使用”时才初始化它们。主动使用分为六种，除了这六种之外的使用都是被动使用： * 创建类的实例：主动new一个实例。 * 访问某个类或接口中的静态变量，或为该静态变量赋值。 * 调用某个类的静态方法。 * 反射（ 如Class.forName() ) * 初始化一个类的子类。 * Java虚拟机启动时被标明为启动类的类。","categories":[],"tags":[]},{"title":"JS高级","slug":"JS高级","date":"2019-07-22T14:11:47.000Z","updated":"2019-07-22T14:30:10.848Z","comments":true,"path":"2019/07/22/JS高级/","link":"","permalink":"http://yoursite.com/2019/07/22/JS高级/","excerpt":"","text":"JS高级1、基础总结深入数据类型首先是数据类型的分类，可分为基本数据类型（也可叫值类型）和引用类型（也可叫对象类型）； 其中基本数据类型有五种，包含：String（任意字符串）、Number（任意数字）、Boolean（true/false)、undefined(undefined)、null(null); 引用类型有三种：Object、Function、Array。其中，Function和Array都是特殊的对象；如果说对象是用来存数据的，那么Function是用来存代码块的，而且代码块是可执行的；Array则是有序存储数据而且有下标。 了解了数据类型的分类，就应该清楚如何判断这些类型。JS中通常可以使用typeof、instanceof和===来对不同的类型进行判断。 typeof主要用于判断基本类型，这些基本类型中包含String、Number、Boolean和undefined，判断返回的结果是这些类型的字符串表达式，需要注意的是，typeof并不能判断null和Object，Array和Object. instanceof 用于判断对象类型， ===表示全等，可判断undefined，如：var a; a===undefined(等价于typeof a === ‘undefined’)。===能够判断undefined的原因是undefined只有一个取值，那就是undefined。","categories":[],"tags":[]},{"title":"单例模式","slug":"单例模式","date":"2019-07-20T15:16:09.000Z","updated":"2019-08-07T14:04:11.074Z","comments":true,"path":"2019/07/20/单例模式/","link":"","permalink":"http://yoursite.com/2019/07/20/单例模式/","excerpt":"","text":"单例模式的优点： 单例模式能够避免对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间。 能够避免由于操作多个实例导致的逻辑错误。 如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个 值得考虑的选择。单例模式分为饿汉式单例和懒汉式单例。对于饿汉式单例，我们都知道一个对象的创建依赖于类中的构造方法，为了避免随意创建，第一步先私有化构造方法，第二步提供一个静态实例，第三步提供一个public修饰的static方法，用于返回该实例。1234567public class Singleton&#123; private static Singleton instance = new Singleton(); private Single()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 饿汉单例模式虽然只创建一次实例，但是它也存在很明显的缺点，就是这个单例不管用没用到，都会在类加载的时候被创建，内存就会被浪费。这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况，但是，如果单例占用的内存比较大，或单例只是在某个场景下才会用到，使用饿汉式就不合适了，这时候就需要用到懒汉式进行延迟加载。 12345678910public class Singleton&#123; private static Singleton instance = null; private Singletong()&#123;&#125; public static Singleton getInstance()&#123; if(null == instance)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式好处是在需要的时候才会去创建，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。适用场景：如果某个单例适用的次数少，并且创建到哪里消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉式就是一个不错的选择。缺点：如果在不考虑线程安全问题的情况下，懒汉式的这种写法业务方；相反，如果存在线程安全的时候，代码执行到if语句的时候就会出现问题，可能导致创建多个实例，因此还需将代码进一步优化如下： 12345678910public class Singeton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static synchrinized Singleton getInstance()&#123; if(null == instance)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 参考文章[Java单例模式的不同写法]{https://blog.csdn.net/fly910905/article/details/79286680}","categories":[],"tags":[]},{"title":"Java面试题-基础篇2","slug":"Java面试题2","date":"2019-07-20T14:38:18.000Z","updated":"2019-07-20T15:15:37.061Z","comments":true,"path":"2019/07/20/Java面试题2/","link":"","permalink":"http://yoursite.com/2019/07/20/Java面试题2/","excerpt":"","text":"1、是否可以从一个static方法内部发出对非static方法的调用？不可以，因为非static方法是要与对象关联在一起的，要使用非static的方法必须要先创建对象，有了对象才能调用非static方法；而对于static方法，它的调用不需要创建类，也就是说程序在加载一个类的字节码时候该方法就可以被调用，而此时非static方法不一定已经创建，如果从static方法中发出对非static方法的调用，就无法确定飞蛾static方法是关联到哪个对象上的，该调用方式在逻辑上是不通的。2、Integer和int的区别？int是Java提供的8种基本数据类型之一，同时Java也为每种基本数据类型提供了对应的封装类，而Integer则是int的封装类；int默认值为0，Integer默认值为null，所以Integer可以区分出未赋值和值为0的区别，int就无法表达出未赋值的情况。 在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以会根据其值是否为null来判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0. 此外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。3、Math.round(11.5)等于多少？ Math.round(-11.5)等于多少？Math类中提供了三个与取整数有关的方法：ceil、floor、round，其中，ceil表示将一个小数向上取整，floor表示向下取整，round表示四舍五入。 例如：Math.ceil(11.3)结果为12，Mah.ceil(-11.3)结果为-11； Math.floor(11.8)结果为11，Math.floor(-11.8)结果为-12；稍难理解的是Math.round()，它的算法是Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以对于Math.round(11.3)来说，先对其进行加上0.5后向下取整变换-&gt;Math.floor(11.8),向下取整后结果为11，对于Math.round(-11.4)，对其变换后为Math.floor(-10.9),向下取整后结果为11.","categories":[],"tags":[]},{"title":"个人博客搭建（github + hexo）","slug":"个人博客搭建（github-hexo）","date":"2019-07-19T01:30:59.000Z","updated":"2019-07-26T07:03:05.332Z","comments":true,"path":"2019/07/19/个人博客搭建（github-hexo）/","link":"","permalink":"http://yoursite.com/2019/07/19/个人博客搭建（github-hexo）/","excerpt":"","text":"对于开发人员来说，拥有自己的一个博客是很有必要的，开发人员可以在多个平台上写，只需要注册自己的一个账号即可，例如：CSDN、简书、掘金等。当然，也可以自己搭建一个属于自己的博客。现在来讲讲使用Hexo框架来搭建个人博客，并部署到github。 1、使用Hexo框架搭建博客需要先安装node.js，没有安装的话可以进入官网下载LTS版本安装即可，安装步骤一直next。 2、安装好之后使用终端输入命令node -v和 npm -v，如果能够显示相应的版本信息，说明node.js的安装是成功的。 3、由于国内镜像源速度慢，在使用前可以先使用npm包管理器安装cnpm 在终端输入：npm install -g cnpm –registry=https://registry.npm.taobao.org 安装后输入cnpm -v 出现版本信息则为成功 4、接下来使用cnpm -g(全局)安装hexo框架 输入命令：cnpm install -g hexo-cli","categories":[],"tags":[]},{"title":"Java面试题基础篇","slug":"Java面试题","date":"2019-07-19T01:16:04.000Z","updated":"2019-07-19T15:11:00.482Z","comments":true,"path":"2019/07/19/Java面试题/","link":"","permalink":"http://yoursite.com/2019/07/19/Java面试题/","excerpt":"","text":"1、一个“.java”源文件是否可以包括多个类（不是内部类）？有什么限制？可以有多个类，但只能有一个public修饰的类，并且public的类名必须与文件名相一致。2、Java有没有goto？java中的保留字，现在没有在java中使用3、说说&amp;与&amp;&amp;的区别。&amp;与&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式结果都为true时，整个运算结果才为true,否则，只要有一方为false，则结果都为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式。例如if(str!= null &amp;&amp; !str.equals(s))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException，如果将&amp;&amp;改为&amp;，则会抛出NullPointerException。 &amp;还可以用作位运算符，当&amp;操作符两边的表达式不是boolean类型时，&amp;表示按位与操作，我们通常使用0x0f来与一个整数进行&amp;运算，来获取该整数的最低4个bit位，例如，0x31 &amp; 0x0f的结果为0x01。4、switch语句能否作用在byte上，能否作用在long上，能否作用在String上？在Java1.7之前，在switch(e) 中，e只能是一个整数表达式或者枚举常量，整数表达式可以是int基本类型或Integer包装类型，由于byte、short、char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以。在Java1.7之后，switch语句已经支持String这种写法了。5、short s1 = 1; s1 = s1 + 1;有什么错？ short s1 = 1; s1 += 1;;有什么错？对于short s1 = 1; s1 = s1 + 1;由于s1一开始是short类型，在s1 = s1 + 1的表达式中，等号右边short类型的s1加上int类型的数字1，此时变量类型会提升为int类型，而在等号左边s1依然是short类型，将int类型的值赋给short类型编译器将会提示需要强制装换类型的错误。 对于short s1 = 1; s1 += 1; 由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。6、char型变量中能不能存储一个中文汉字？为什么？char型变量是用来存储Unicode编码的字符的，Unicode编码字符集中包含了汉字，所以，char型变量是可以用来存储汉字的。不过，如果某个特殊的汉字没有被包含在Unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊的汉字。补充说明：Unicode编码占用两个字节，所以，char类型的变量也只是占用两个字节。7、用最有效的方法算出2乘以8等于几？最有效的方法当属位运算，所以2&lt;&lt;3（2的二进制数左移3位）能最有效算出。这是因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算是CPU直接支持的，效率最高，所以2乘以8等于几的最有效方法是2&lt;&lt;3. 例如：0000 0010是2的二进制数，将其左移三位后为0001 0000，移位后的二进制数换算为十进制就是16，也就是2乘以8的结果。8、使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于以下语句： final StringBuffer a = new StringBuffer(&quot;hello&quot;); 执行a = new StringBuffer(&quot;&quot;);时将报告编译器错误； 但是，执行a.append(&quot;world!&quot;);时则可以通过编译。9、静态变量和实例变量的区别？在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建实例对象，静态变量就会被分配空间，也就可以直接使用了。总之实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-15T13:00:33.263Z","updated":"2019-07-15T13:00:33.263Z","comments":true,"path":"2019/07/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}